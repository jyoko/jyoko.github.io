<!doctype html><html class="theme-next use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2"><meta name="description" content="One of those things that lots of new coders ask about is recursion. I mean I get it, most people learning to code will run into explanations about recursion, if only that it relates to functions and a"><meta property="og:type" content="article"><meta property="og:title" content="Let's Talk Recursion"><meta property="og:url" content="http://jyoko.github.io/2015/11/17/lets-talk-recursion/index.html"><meta property="og:site_name" content="jrandm thoughts"><meta property="og:description" content="One of those things that lots of new coders ask about is recursion. I mean I get it, most people learning to code will run into explanations about recursion, if only that it relates to functions and a"><meta property="og:updated_time" content="2016-02-19T19:28:01.627Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Let's Talk Recursion"><meta name="twitter:description" content="One of those things that lots of new coders ask about is recursion. I mean I get it, most people learning to code will run into explanations about recursion, if only that it relates to functions and a"><script type="text/javascript" id="hexo.configuration">var CONFIG={scheme:"Mist",sidebar:"remove",motion:!0};</script><title>Let's Talk Recursion | jrandm thoughts</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><!--[if lte IE 8]><div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div><![endif]--><div class="container one-column page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">jrandm thoughts</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Whatever crosses my mind</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-home fa-fw"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-th fa-fw"></i><br>Categories</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-user fa-fw"></i><br>About</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-archive fa-fw"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline">Let's Talk Recursion</h1><div class="post-meta"><span class="post-time">Posted on <time itemprop="dateCreated" datetime="2015-11-17T03:00:00-05:00" content="2015-11-17">2015-11-17</time></span> <span class="post-category">&nbsp; | &nbsp; In <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/learn2code/" itemprop="url" rel="index"><span itemprop="name">Learn2Code</span></a></span></span></div></header><div class="post-body"><span itemprop="articleBody"><p>One of those things that lots of new coders ask about is recursion. I mean I get it, most people learning to code will run into explanations about recursion, if only that it relates to functions and allows for some elegant solutions. Unfortunately, that's basically useless. Since I've had the good fortune to give a few lectures on the subject to beginning coders and explore the concept in some tutoriing sessions, hopefully this post helps you make some sense out of recursion.</p><p>If you want to watch a video (and see where I ripped most of my lesson from), check out the first lesson of Structure and Interpretation of Computer Programs (SICP) on MIT OpenCourseware.</p><p>First, let's make sure we all know the meaning of some words:</p><ul><li>Recursion: A process that repeats itself</li><li>Iteration: A repeating process</li></ul><p>These are <strong>EXTREMELY</strong> similar, but crucially different. An iterative process may also be recursive, but a recursive process is not necessarily iterative.</p><p>...Just like the all squares are rectangles but not all rectangles are squares.</p><p>The computer sciency and mathematical definitions are also similar: A recursive function references itself in its definition; iteration is repeating a given definition.</p><p>So what the hell does that mean, right? Basically, any list of instructions that has a 'Repeat steps 2-4 until...' can be thought of as recursive, where the <em>base case</em> is whatever appears after the 'until.' Repeating steps are more common, as anyone who's assembled furniture is familiar with (&quot;Now take part E and insert into hole H [...and do the same thing you did on the other side...]&quot;).</p><p>Why have I spent so many words trying to highlight this minor difference? Because ANY problem you can solve iteratively (ie: with a FOR or WHILE loop) can also be solved recursively, and vice versa. The difference is in structure of your logic/code, and in how it looks while it's executing (actively running).</p><p>In fact, there are two main differences in how a recursive function will execute. The function can be either purely recursive (which will inflate the call stack) or iteratively recursive (which may not). That potential improvement is commonly known as tail-call optimization (more correctly, eliminination), and it's coming soon to Javascript.</p><p>Let's take a look at this in code, starting with a simple function that takes a a number N returns a value as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(N-k)+(N-k_next) ... where k=<span class="number">0</span>, incrementing by <span class="number">1</span> each step until N-k=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">N+(N-<span class="number">1</span>)+(N-<span class="number">2</span>)+(N-<span class="number">3</span>) ... until N-k=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Example: N = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>-<span class="number">0</span>) + (<span class="number">3</span>-<span class="number">1</span>) + (<span class="number">3</span>-<span class="number">2</span>) + (<span class="number">3</span>-<span class="number">3</span>)</span><br><span class="line">  <span class="number">3</span>   +   <span class="number">2</span>   +   <span class="number">1</span>   +   <span class="number">0</span></span><br><span class="line">              <span class="number">6</span></span><br></pre></td></tr></table></figure><h2>Iteration</h2><p>We'll start with method you're probably most familiar with, and one of the first tools most programmers learn. You can use a FOR or WHILE loop to repeat (ie: iterate) over a given block of code.I hope most folks reading this would feel confident writing code to accomplish the above task!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iteration = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (n; n&gt;<span class="number">0</span>; n--) &#123;</span><br><span class="line">    sum+=n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(iteration(<span class="number">3</span>)); <span class="comment">//-&gt; 6</span></span><br></pre></td></tr></table></figure><p>The above process runs very vertically, like so:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">sum = sum + i</span><br><span class="line">sum =  <span class="number">0</span>  + <span class="number">3</span></span><br><span class="line">sum =  <span class="number">3</span>  + <span class="number">2</span></span><br><span class="line">sum =  <span class="number">5</span>  + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">6</span> &lt;-- sum</span><br></pre></td></tr></table></figure><p>Where we start with the 0 value, rather than adding it at the end.</p><h2>Recursion</h2><p>Next we'll run through a naive recursive solution. There's one GIANT thing every recursive function needs: A base case, or ending condition. If you don't have some condition where the function returns a value, rather than calling itself, the recursion will never end! Practically, you'll get a call stack exceeded error when that happens - sometimes it will crash or freeze either your computer or the executing application.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> recursive = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n===<span class="number">0</span>) &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">  <span class="keyword">return</span> n+recursive(n-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(recursive(<span class="number">3</span>)); <span class="comment">//-&gt; 6</span></span><br></pre></td></tr></table></figure><p>Below is a rough drawing of how this process happens. Pay particular attention to the way it forms a sideways pyramid - the operations are dependent upon the next call completing before you can get the final answer, so this recursion will grow in size for every call until it reaches the base case. You need to maintain the information from each call to <code>recursive</code> until you reach the 0 before you can add the numbers together and get an answer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">recursive(<span class="number">3</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">3</span> + recursive(<span class="number">2</span>)                         </span><br><span class="line">                 <span class="keyword">return</span> <span class="number">2</span> + recursive(<span class="number">1</span>)            </span><br><span class="line">                               <span class="keyword">return</span> <span class="number">1</span> + recursive(<span class="number">0</span>)</span><br><span class="line">                                             <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                               <span class="keyword">return</span> <span class="number">1</span> + <span class="number">0</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="number">2</span> + <span class="number">1</span> + <span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> + <span class="number">0</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>That pyramid is what I'm referring to when I say &quot;call stack&quot; - you can picture in your mind a stack of functions being executed when your program runs. Tilt your head to the right and you can imagine placing each of those function calls on top of each other, then pushing the numbers back down until we get our final number.</p><h2>Iterative Recursion</h2><p>This method is a mix of the previous two, but with a key difference. The return value of this function is not a new operation dependent upon another function call to complete, but simply another call to itself. By maintaining the state of the step in the arguments to the function, a sufficiently smart compiler can replace the existing function call with the next one! As with the imperative iteration above using the FOR loop, this process can be stopped &amp; restarted at any given step: We know the sum, and how much farther to go to get to 0. The pure recursive function cannot stop &amp; restart without maintaining all of the information from the previous functions, any individual function from that list getting called later will give you a different answer (eg: <code>recursive(2)</code> will never give us back 6).</p><p>Note the extra, hidden argument that is only used when making the recursive call here.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterative = <span class="function"><span class="keyword">function</span>(<span class="params">n,sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = sum || <span class="number">0</span>; <span class="comment">// default value for hidden parameter sum</span></span><br><span class="line">  <span class="keyword">if</span> (n===<span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">  <span class="keyword">return</span> iterative(n-<span class="number">1</span>,sum+n);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(iterative(<span class="number">3</span>)) <span class="comment">//-&gt; 6</span></span><br></pre></td></tr></table></figure><p>Again, examine the way this function executes visually:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iterative(<span class="number">3</span>)</span><br><span class="line">         <span class="keyword">return</span> iterative(<span class="number">2</span>,<span class="number">0</span>+<span class="number">3</span>)</span><br><span class="line">         <span class="keyword">return</span> iterative(<span class="number">1</span>,<span class="number">3</span>+<span class="number">2</span>)</span><br><span class="line">         <span class="keyword">return</span> iterative(<span class="number">0</span>,<span class="number">5</span>+<span class="number">1</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>Notice that this structure also extends horizontally, but only once, before moving in a vertical fashion like the first example of iteration. The importance of this <strong>single</strong> function is that s sufficiently smart compiler can replace the previous call with the next one and merely update the argument values. This is similar to a GOTO statement or how the machine code for a loop would look. In purely functional languages, this tail call method is the only way to iterate.</p><h2>Fibonacci Sequence</h2><p>Below are examples of a famous mathematical operation and favorite for demonstrating recursion, the Fibonacci function.</p><p>This sequence is typically defined as follows:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">F</span><span class="params">(<span class="number">0</span>)</span></span> = <span class="number">0</span>, <span class="function"><span class="title">F</span><span class="params">(<span class="number">1</span>)</span></span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">F</span><span class="params">(n)</span></span> = <span class="function"><span class="title">F</span><span class="params">(n-<span class="number">1</span>)</span></span> + <span class="function"><span class="title">F</span><span class="params">(n-<span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure><p>Which creates a pattern of numbers like so:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">144.</span>..</span><br></pre></td></tr></table></figure><p>The first thing you should notice (assuming you read this in order) is that the definition is recursive! You can see that the first step is to define the two base cases, then for every subsequent number the same function is applied repeatedly on decreasing values, until either 0 or 1 is reached.</p><p>At this point, you should try to implement this function yourself in all three of the ways discussed, before looking at the solutions below.</p><p><strong>Note:</strong> You can run the solution code below and verify the answers by changing the variable n to whatever Fibonacci number you wish to generate. The functions are written in a certain order so you can see the runtime differences by examing the time it takes them to print - what happens on larger values of n?</p><p><strong>Second note:</strong> Before you put in a number over 30, make sure you know how to kill a long-running process in Node or your browser!</p><figure class="highlight js"><figcaption><span>Fibonacci Solutions</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fib_iter = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> current = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> temp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    temp = current;</span><br><span class="line">    current = prev+current;</span><br><span class="line">    prev = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Iteration (for loop) fib sequence for '</span>+n+<span class="string">':'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fib_iter(n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fib_iterRecur = <span class="function"><span class="keyword">function</span>(<span class="params">n,cur,prev</span>) </span>&#123;</span><br><span class="line">  prev = prev || <span class="number">0</span>;</span><br><span class="line">  cur = cur || <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n===<span class="number">1</span>) <span class="keyword">return</span> cur;</span><br><span class="line">  <span class="keyword">return</span> fib_iterRecur(n-<span class="number">1</span>,cur+prev,cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Recursive iteration fib sequence for '</span>+n+<span class="string">':'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fib_iterRecur(n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fib_recur = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fib_recur(n-<span class="number">1</span>)+fib_recur(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Recursive fib sequence for '</span>+n+<span class="string">':'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fib_recur(n));</span><br></pre></td></tr></table></figure><p>And the last thing I'll mention is my terminology usage in this article. I use &quot;iterative recursion&quot; to reference the tail-recursive structure because I think it's descriptive and is an easy way to remember what's happening, but that's not super-common term. Purely functional languages tend to just call this process iteration and other languages will refer to it as &quot;tail call optimization&quot; or &quot;tail call elimination&quot; if supported, because the compiler or interpreter will reuse/replace the previous function call with the next one. In languages without this feature (like Javascript currently, as of Feb 2016), the runtime is often better using iterative recursion because there are often fewer function calls and the final solution doesn't have to be computed as you move back down the stack, but you will still encounter call stack exceeded errors at some point.</p></span></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2015/11/8/reduce-all-the-things-part2/" rel="next" title="Reduce All the Things! (part 2)"><i class="fa fa-chevron-left"></i> Reduce All the Things! (part 2)</a></div><div class="post-nav-prev post-nav-item"><a href="/2016/1/12/so-you-were-a-hacker/" rel="prev" title="So You Were a Hacker">So You Were a Hacker <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2016</span> <span class="with-love"><i class="icon-next-heart fa fa-beer"></i></span> <span class="author" itemprop="copyrightHolder">jyoko</span></div><div class="powered-by">Powered by <a class="theme-link" href="http://hexo.io">Hexo</a></div><div class="theme-info">Theme - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div></div></footer><div class="back-to-top"></div></div><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script><script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script><script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script><script type="text/javascript" id="sidebar.toc.highlight">$(document).ready(function(){function o(){$(s+" "+r).removeClass(r.substring(1))}function t(){i(),n()}function i(){var o=$(".sidebar").height()-a.position().top-$(".post-toc-indicator-bottom").height();return a.css("height",o),o}function n(){c(".post-toc-indicator-top",a.scrollTop()>0?"show":"hide"),c(".post-toc-indicator-bottom",a.scrollTop()>=a.find("ol").height()-a.height()?"hide":"show")}function e(o){o.on("mousewheel DOMMouseScroll",function(o){var t=o.originalEvent,i=t.wheelDelta||-t.detail;this.scrollTop+=30*(0>i?1:-1),o.preventDefault(),n()})}function c(o,t){var i=$(o),n="show"===t?1:0;i.velocity?i.velocity("stop").velocity({opacity:n},{duration:100}):i.stop().animate({opacity:n},100)}var s=".post-toc",a=$(s),r=".active-current";a.on("activate.bs.scrollspy",function(){var t=$(s+" .active").last();o(),t.addClass("active-current"),a[0].scrollTop=t.position().top}).on("clear.bs.scrollspy",function(){o()}),$(document).on("sidebar.motion.complete",function(){t()}),$("body").scrollspy({target:s}),$(window).on("resize",function(){$(".sidebar").hasClass("sidebar-active")&&t()}),e(a)});</script><script type="text/javascript" id="sidebar.nav">$(document).ready(function(){var t=$("html"),i=200,a=$.isFunction(t.velocity);$(".sidebar-nav li").on("click",function(){var t=$(this),o="sidebar-nav-active",e="sidebar-panel-active";if(!t.hasClass(o)){var s=$("."+e),n=$("."+t.data("target"));a?s.velocity("transition.slideUpOut",i,function(){n.velocity("stop").velocity("transition.slideDownIn",i).addClass(e)}):s.animate({opacity:0},i,function(){s.hide(),n.stop().css({opacity:0,display:"block"}).animate({opacity:1},i,function(){s.removeClass(e),n.addClass(e)})}),t.siblings().removeClass(o),t.addClass(o)}}),$(".post-toc a").on("click",function(i){i.preventDefault();var o=escapeSelector(this.getAttribute("href")),e=$(o).offset().top;a?t.velocity("stop").velocity("scroll",{offset:e+"px",mobileHA:!1}):$("html, body").stop().animate({scrollTop:e},500)}),motionMiddleWares.sidebar=function(){var t=$(".post-toc-content");"post"===CONFIG.sidebar&&t.length>0&&t.html().trim().length>0&&displaySidebar()}});</script><script type="text/javascript" src="/js/bootstrap.js"></script></body></html>